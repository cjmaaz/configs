---
description: Apply this rule when creating, modifying, or executing ANY Apex test classes in Salesforce Sales Cloud or Service Cloud orgs. This rule enforces best practices for test data creation, factory usage, schema validation, method visibility awareness, PMD exceptions, comprehensive test coverage (90%+), proper test execution commands, and mandatory log verification.
alwaysApply: false
---

# Apex Test Class Creation and Execution Ruleset

## Applicability
Apply this rule when creating, modifying, or executing ANY Apex test classes in Salesforce Sales Cloud or Service Cloud orgs. This includes unit tests, integration tests, and test data setup methods.

---

## PHASE 1: Pre-Development Analysis

### 1.1 MANDATORY: Check for Test Data Factory
**BEFORE writing ANY test data creation code:**

```bash
# Search for test data factory classes
find force-app -name "*TestDataFactory*" -o -name "*TestFactory*" -o -name "*DataFactory*"
```

**DO:**
- ✅ ALWAYS search the codebase for existing test data factory classes FIRST
- ✅ USE factory methods for ALL standard and custom object creation
- ✅ Review factory class to understand available methods and parameters
- ✅ Leverage factory methods to ensure consistent test data patterns

**DON'T:**
- ❌ NEVER create test data manually if a factory method exists
- ❌ NEVER duplicate data creation logic that exists in factory classes
- ❌ NEVER assume there is no factory without searching first

### 1.2 MANDATORY: Schema Validation
**BEFORE writing ANY Apex code that references fields:**

**DO:**
- ✅ ALWAYS consult schema files in `config/schema/` directory for object definitions
- ✅ VERIFY field API names, data types, and relationships from schema files
- ✅ CHECK field properties: required, writable, formula, lookup/master-detail
- ✅ VALIDATE RecordType DeveloperNames from schema before using
- ✅ CONFIRM picklist values are valid for the org

**DON'T:**
- ❌ NEVER assign values to formula fields (they are read-only)
- ❌ NEVER guess field API names or assume they exist
- ❌ NEVER use hardcoded RecordType IDs without validation
- ❌ NEVER skip schema validation even for "obvious" standard fields

### 1.3 MANDATORY: Understand Method Visibility
**BEFORE writing test methods:**

**DO:**
- ✅ IDENTIFY which methods are public, private, and static in the class under test
- ✅ TEST private methods ONLY through their public method callers
- ✅ CALL static methods using ClassName.methodName() syntax
- ✅ INSTANTIATE the class if testing instance methods

**DON'T:**
- ❌ NEVER attempt to call private methods directly in tests
- ❌ NEVER create workarounds to access private methods
- ❌ NEVER mark private methods as @TestVisible unless absolutely necessary

---

## PHASE 2: Test Class Design

### 2.1 Test Class Structure Requirements

**DO:**
- ✅ CREATE one test class per Apex class (naming: ClassNameTest)
- ✅ USE @isTest annotation at class level (NOT @isTest(SeeAllData=false))
- ✅ CREATE @testSetup method for shared test data creation
- ✅ DESIGN 3-6 comprehensive test methods covering ALL scenarios
- ✅ STRUCTURE each test method: Setup (if needed) → Execute → Assert
- ✅ USE Test.startTest() and Test.stopTest() to reset governor limits
- ✅ COMBINE related test scenarios into single comprehensive methods
- ✅ NAME methods descriptively: testMethodNameScenario (e.g., testGetAccountsWithFiltering)

**DON'T:**
- ❌ NEVER create 20+ small test methods when 4-6 comprehensive ones suffice
- ❌ NEVER use SeeAllData=true (violates best practices)
- ❌ NEVER skip @testSetup if multiple methods need common data
- ❌ NEVER create verbose test classes (keep ratio: ~1.5x lines of production code)

### 2.2 PMD Ruleset Exceptions for Test Classes

**IMPORTANT: Test classes are EXEMPT from PMD method line count rules.**

**DO:**
- ✅ IGNORE PMD MethodLineLengthRule for test classes
- ✅ CREATE comprehensive test methods that cover multiple scenarios (50-100+ lines acceptable)
- ✅ PRIORITIZE readability and coverage over method length
- ✅ CONSOLIDATE related assertions in single methods to reduce class size

**DON'T:**
- ❌ NEVER split comprehensive test methods artificially to satisfy PMD line limits
- ❌ NEVER sacrifice test coverage for PMD compliance in test classes

### 2.3 Test Data Creation Strategy

**DO:**
- ✅ CREATE test data that EXACTLY matches ALL SOQL query filter criteria
- ✅ ANALYZE WHERE clauses in production code to understand filtering logic
- ✅ SET all required fields for query filters (RecordType, Status, Active flags, Date fields)
- ✅ CREATE both positive (should match) and negative (should not match) test data
- ✅ ENSURE master-detail and lookup relationships are properly populated
- ✅ SET EffectiveFrom, EffectiveTo, and date-based filters correctly
- ✅ POPULATE formula field dependencies (not the formula field itself)
- ✅ CREATE data for edge cases: null values, empty strings, boundary conditions

**DON'T:**
- ❌ NEVER create generic test data without understanding query filters
- ❌ NEVER skip required fields that impact query results
- ❌ NEVER assume test data will match queries without validation
- ❌ NEVER create only happy-path data (test failure scenarios too)

### 2.4 Coverage Requirements

**TARGET: 90%+ code coverage for all production Apex classes**

**DO:**
- ✅ COVER all public methods with positive and negative test cases
- ✅ COVER all conditional branches (if/else, switch cases, ternary operators)
- ✅ COVER static methods using ClassName.methodName() syntax
- ✅ COVER exception handling (try blocks) with valid scenarios
- ✅ COVER Callable interface call() method with various actions
- ✅ TEST all filtering logic combinations (PNC flags, RecordTypes, Status fields)
- ✅ ACCEPT 90-98% coverage (catch blocks and unreachable code are acceptable to leave uncovered)

**DON'T:**
- ❌ NEVER aim for 100% coverage by testing unrealistic exception scenarios
- ❌ NEVER skip testing static utility methods
- ❌ NEVER ignore untested branches (use debug logs to identify)
- ❌ NEVER deploy without verifying actual coverage percentage

---

## PHASE 3: Writing Test Methods

### 3.1 Assertion Best Practices

**DO:**
- ✅ USE Assert.isNotNull() for null checks
- ✅ USE Assert.areEqual(expected, actual, 'message') for value comparisons
- ✅ USE Assert.isTrue() / Assert.isFalse() for boolean checks
- ✅ PROVIDE descriptive assertion messages explaining what is being tested
- ✅ ASSERT on specific field values to verify data correctness
- ✅ VERIFY collection sizes (list.size(), set.size(), map.size())
- ✅ HANDLE potential null returns gracefully in assertions

**DON'T:**
- ❌ NEVER use System.assert() (deprecated in favor of Assert class)
- ❌ NEVER write assertions without descriptive messages
- ❌ NEVER assume methods return non-null without checking
- ❌ NEVER skip assertions (every test must verify behavior)

### 3.2 Testing Query Methods

**DO:**
- ✅ VERIFY query methods return expected data structures (List, Set, Map)
- ✅ TEST with data that matches ALL filter criteria
- ✅ TEST with data that fails ONE filter criterion (verify exclusion)
- ✅ TEST with empty result scenarios (no matching data)
- ✅ TEST with multiple records to verify deduplication logic
- ✅ VALIDATE returned field values match expected transformations

**DON'T:**
- ❌ NEVER assume queries will return data without proper test setup
- ❌ NEVER skip testing query filter combinations
- ❌ NEVER ignore query security modes (USER_MODE vs SYSTEM_MODE)

### 3.3 Testing Callable Interface

**DO:**
- ✅ TEST call() method with all valid action strings
- ✅ TEST with invalid/null action strings (verify default behavior)
- ✅ STRUCTURE test parameters correctly: {'input'=>Map, 'output'=>Map, 'options'=>Map}
- ✅ VERIFY output Map contains expected keys and values
- ✅ CAST return values to expected types for further assertions

**DON'T:**
- ❌ NEVER skip testing invalid action handling
- ❌ NEVER assume call() will always succeed without error handling

---

## PHASE 4: Test Execution and Coverage Verification

### 4.1 MANDATORY: Synchronous Test Execution Command

**USE THIS COMMAND for accurate code coverage:**

```bash
sf apex run test --class-names YourTestClassName -o OrgAlias --synchronous --code-coverage --result-format human --wait 10
```

**DO:**
- ✅ USE `--synchronous` flag to get immediate, accurate coverage results
- ✅ USE `--code-coverage` flag to include coverage data in output
- ✅ USE `--result-format human` for readable output
- ✅ SET `--wait 10` (10 minutes timeout) for complex test suites
- ✅ PIPE output to file: `2>&1 | tee test-results.txt` for review
- ✅ REVIEW coverage percentage in command output

**DON'T:**
- ❌ NEVER query ApexCodeCoverageAggregate immediately after deployment (stale data)
- ❌ NEVER use asynchronous test execution when coverage validation is needed
- ❌ NEVER skip --synchronous flag during coverage verification
- ❌ NEVER assume deployment success equals coverage success

### 4.2 Deployment with Test Execution

**USE THIS COMMAND for deployment with tests:**

```bash
sf project deploy start --manifest './manifest/your-manifest.xml' -o OrgAlias --test-level RunSpecifiedTests --tests YourTestClassName --ignore-conflicts --wait 10
```

**DO:**
- ✅ CREATE deployment manifest including both production class and test class
- ✅ USE `--test-level RunSpecifiedTests` with `--tests ClassName` for targeted testing
- ✅ USE `--ignore-conflicts` to handle source tracking issues
- ✅ WAIT for deployment to complete (--wait 10)
- ✅ VERIFY all tests pass before proceeding to coverage check

**DON'T:**
- ❌ NEVER deploy without running tests
- ❌ NEVER use --test-level NoTestRun for production deployments
- ❌ NEVER skip manifest creation

### 4.3 MANDATORY: Apex Log Verification

**AFTER test execution, ALWAYS check logs for errors:**

```bash
sf apex tail log -o OrgAlias
```

**DO:**
- ✅ SEARCH logs for: EXCEPTION, ERROR, FATAL_ERROR keywords
- ✅ VERIFY no hidden failures from triggers, flows, or process builders
- ✅ CHECK governor limit warnings (SOQL, DML, CPU time)
- ✅ REVIEW automation behavior triggered by test data

**DON'T:**
- ❌ NEVER skip log verification even if tests pass
- ❌ NEVER ignore warnings in logs
- ❌ NEVER assume passing tests mean no underlying issues

---

## PHASE 5: Common Issues and Resolutions

### 5.1 Zero Coverage Despite Passing Tests

**CAUSE:** Test data doesn't match production code query filters

**RESOLUTION:**
1. READ production code SOQL WHERE clauses line by line
2. LIST all filter conditions (RecordType, Status, Active, Dates, Flags)
3. CREATE test data that satisfies EVERY filter condition
4. VERIFY lookup/master-detail relationships are populated
5. ENSURE formula field dependencies are set correctly
6. RE-RUN synchronous tests to verify coverage increase

### 5.2 "Field is not writeable" Error

**CAUSE:** Attempting to assign value to formula field

**RESOLUTION:**
1. CHECK schema file for field calculateFormula property
2. REMOVE assignment to formula field from test code
3. SET dependent fields that formula uses for calculation
4. REDEPLOY and verify

### 5.3 "Method is not visible" Error

**CAUSE:** Attempting to call private method directly

**RESOLUTION:**
1. IDENTIFY public method that calls the private method
2. REWRITE test to invoke public method with parameters that trigger private method
3. VERIFY coverage of private method increases through public method call

### 5.4 Assertion Failures with Empty Results

**CAUSE:** Query returns empty due to filter mismatch

**RESOLUTION:**
1. ADD debug statements to log query results
2. VERIFY RecordType.DeveloperName matches constant values
3. CHECK Status/Active fields are set correctly
4. ENSURE dates (EffectiveFrom/To) are within valid ranges
5. VALIDATE master-detail parent records exist before children

---

## PHASE 6: Final Checklist

**BEFORE considering test class complete:**

- [ ] ✅ Test data created using factory methods where available
- [ ] ✅ All fields validated against schema files
- [ ] ✅ 90%+ code coverage achieved (verified with synchronous test run)
- [ ] ✅ All tests passing (0 failures)
- [ ] ✅ Apex logs reviewed (no EXCEPTION/ERROR entries)
- [ ] ✅ Test class size is reasonable (not overly verbose)
- [ ] ✅ Assertions are descriptive and meaningful
- [ ] ✅ Both positive and negative scenarios tested
- [ ] ✅ Edge cases handled (null, empty, boundary conditions)
- [ ] ✅ Deployment manifest created and validated
- [ ] ✅ Production class and test class both deployed successfully

---

## Command Reference Summary

```bash
# Find test data factories
find force-app -name "*TestDataFactory*"

# Synchronous test execution with coverage (PRIMARY METHOD)
sf apex run test --class-names TestClassName -o OrgAlias --synchronous --code-coverage --result-format human --wait 10 2>&1 | tee test-results.txt

# Deploy with tests
sf project deploy start --manifest './manifest/manifest.xml' -o OrgAlias --test-level RunSpecifiedTests --tests TestClassName --ignore-conflicts --wait 10

# Check logs for errors
sf apex tail log -o OrgAlias | grep -E "(EXCEPTION|ERROR|FATAL)"

# Query coverage (use AFTER synchronous test run)
sf data query --query "SELECT ApexClassOrTrigger.Name, NumLinesCovered, NumLinesUncovered FROM ApexCodeCoverageAggregate WHERE ApexClassOrTrigger.Name = 'ClassName'" -o OrgAlias --use-tooling-api
```

---

## Success Criteria

A test class is considered **COMPLETE and PRODUCTION-READY** when:

1. **Coverage ≥ 90%** (verified via synchronous test execution)
2. **All tests passing** (100% pass rate)
3. **No errors in Apex logs** (verified post-execution)
4. **Test data uses factory methods** (where available)
5. **All fields schema-validated** (no assumptions)
6. **Assertions are meaningful** (not just null checks)
7. **Class is maintainable** (not overly verbose, well-organized)
8. **Deployed successfully** (both production and test class)

---
