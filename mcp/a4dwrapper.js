// Auto-generated by the A4D extension v3.3.1 at 15/11/2025, 11:28:44
/**
 * A4D Wrapper to execute MCP servers that use npm packages.
 *
 * This wrapper script provides reliable installation and execution of MCP servers
 * that use npm packages. It addresses common npm installation issues by:
 *
 * 1. Using isolated npm cache directories to avoid conflicts
 * 2. Implementing retry logic for network issues
 * 3. Pre-verifying server installation before starting
 * 4. Providing clean cache cleanup on failures
 * 5. Creating detailed debug logs that survive cache cleanup operations
 *
 * LOGGING STRATEGY:
 * 1. CRITICAL: This script must NOT output anything to stdout during server execution
 * as it would corrupt the MCP protocol communication. All logging goes to stderr and is limited to only critical errors that affect the operation of the server.
 * 2. Wrapper log file is stored in base cache directory: `baseCacheDir/{packageId}.log`
 * 3. npm debug logs are also directed to the same base cache directory
 *
 * IMPORTANT: This wrapper script uses ONLY built-in Node.js libraries and cannot
 * depend on any third-party packages (like execa, etc.) since it is executed
 * directly using `node` without any dependencies.
 *
 * Usage: node a4d-mcp-wrapper.js <config-file-name>
 *
 */

const { spawn } = require("node:child_process")
const fs = require("node:fs").promises
const path = require("node:path")
const { parseArgs } = require("node:util")

// Common NPX arguments
// Ref: https://docs.npmjs.com/cli/v10/commands/npx
const NPX_ARGS = [
	"--yes", // Automatically answers yes to all prompts
	// TODO: Should be able to use "--offline" instead after install/verify succeeds, but leaving it out for now to avoid potential issues
	"--prefer-offline", // Use installed packages if available, otherwise fetch from network
]

// Environment variables for npm/npx commands
// Ref: https://docs.npmjs.com/cli/v10/using-npm/config
const NPM_ENV_VARS = {
	NODE_ENV: "production", // Optimize for production execution
	npm_config_loglevel: "error", // Only show errors in process stdout, all logs are logged to the file in npm_logs directory (for debugging)
	npm_config_fund: "false", // Disable funding messages
	npm_config_audit: "false", // Disable security audit
	npm_config_progress: "false", // Disable progress output
	npm_config_update_notifier: "false", // Disable npm version update notifications
	npm_config_fetch_retries: "5", // Max retries in case of network issues
	npm_config_registry: "https://registry.npmjs.org/", // Lock to default registry
	// logs_dir and cache will be set dynamically in initialize()
}

const NODE_CMD = {
	NPM: "npm",
	NPX: "npx",
}
/**
 * Promise-based wrapper around child_process.spawn with optional output capture
 *
 * Special handling for stdio: 'inherit' - when used (e.g., for MCP server),
 * the child process will share stdin/stdout/stderr with the parent process,
 * enabling transparent MCP protocol communication.
 *
 * @param {string} command - Command to execute
 * @param {string[]} args - Arguments for the command
 * @param {object} options - Spawn options (cwd, env, stdio, captureOutput)
 * @param {boolean} options.captureOutput - If true, captures and returns stdout as string
 * @returns {Promise<string|void>} Promise that resolves with stdout if captureOutput is true, otherwise void
 * @throws {Error} If process fails, times out, or exits with non-zero code
 */
function spawnProcess(command, args = [], options = {}) {
	const { captureOutput = false, ...spawnOptions } = options

	return new Promise((resolve, reject) => {
		const child = spawn(command, args, {
			...spawnOptions,
			shell: true, // Required in Windows to run system npm/npx commands
			// Windows requires process.env for successful npm install
			env: { ...process.env, ...spawnOptions.env, ...NPM_ENV_VARS },
		})

		let stdout = ""
		let stderr = ""

		// Capture output if requested and stdio is not 'inherit'
		if (captureOutput && spawnOptions.stdio !== "inherit") {
			child.stdout?.on("data", (data) => {
				stdout += data.toString()
			})

			child.stderr?.on("data", (data) => {
				stderr += `ERROR: ${data.toString()}`
			})
		}

		// Handle process completion
		child.on("close", (code, signal) => {
			if (code === 0) {
				resolve(captureOutput ? stdout.trim() : undefined)
			} else {
				const errorMsg = signal
					? `Process killed with signal ${signal}`
					: `Process exited with code ${code}${stderr ? `\nStderr: ${stderr}` : ""}`
				reject(new Error(errorMsg))
			}
		})

		// Handle process errors (e.g., command not found)
		child.on("error", (error) => {
			reject(error)
		})
	})
}

/**
 * MCP Server NPM Wrapper Class
 *
 * Handles the complete lifecycle of installing, verifying, and running MCP servers
 * that are distributed as npm packages. Uses isolated cache directories and retry
 * logic to handle common npm installation issues.
 */
class McpServerNpmWrapper {
	/**
	 * @param {object} config - Configuration object with package details
	 * @param {string} config.package - The npm package name
	 * @param {string} config.version - The package version
	 * @param {string[]} config.args - Arguments to pass to the MCP server
	 */
	constructor(config) {
		// Validate required config
		if (!config.package || !config.version || !Array.isArray(config.args)) {
			throw new Error("Missing required configuration: package, version, args")
		}

		this.config = config
		this.baseCacheDir = path.join(__dirname, "a4d-npm-cache")
		// Note: NPM automatically rotates the logs (`npm config get logs-max`)
		this.npmLogsDir = path.join(this.baseCacheDir, "npm_logs")

		// Max retries for install and verify
		this.maxRetries = 3 // Retry up to 3 times for network resilience

		this.packageName = config.package
		this.packageVersion = config.version
		this.packageNameVersion = `${this.packageName}@${this.packageVersion}`
		// Use package name without @ and / to create files, directories, etc.
		this.packageId = this.packageName.replace(/^@/, "").replace(/[@/]/g, "-")
		this.cacheDir = path.join(this.baseCacheDir, this.packageId)

		// Will be set during initialization
		this.logFile = null
	}

	/**
	 * Append to the log file in the cache directory
	 *
	 * @param {string} message - Message to log
	 * @param {string} level - Log level (INFO, ERROR, DEBUG)
	 */
	async log(message, level = "INFO") {
		// Note: Having `console.log` here would corrupt the MCP protocol communication, especially when server is running and connection is refreshed.
		if (!this.logFile) {
			return // Log file not initialized yet
		}

		// Use local time instead of UTC for better user experience
		const timestamp = new Date().toLocaleString("en-US")
		const logEntry = `[${timestamp}] [${level}] ${message}\n`

		try {
			await fs.appendFile(this.logFile, logEntry)
		} catch (error) {
			// If logging fails, write to stderr as fallback
			console.error(`[A4D][MCP] Failed to write to log file: ${error.message}`)
		}
	}

	/**
	 * Log an error message and throw an Error - consolidates common pattern
	 *
	 * @param {string} message - Error message to log and throw
	 * @param {string} level - Log level (defaults to ERROR)
	 * @throws {Error} Always throws an Error with the provided message
	 */
	async logAndThrow(message, level = "ERROR") {
		await this.log(message, level)
		throw new Error(message)
	}

	/**
	 * Initialize the log file in the base cache directory (survives cleanup)
	 * Overwrites any existing log file
	 */
	async initializeLogFile(packageId) {
		if (!packageId) {
			throw new Error("Package ID is required to initialize log file")
		}

		// Place log file in base cache directory with package suffix
		// This ensures it survives cache cleanup operations
		this.logFile = path.join(this.baseCacheDir, `${packageId}.log`)

		try {
			// Ensure base cache directory exists
			await fs.mkdir(this.baseCacheDir, { recursive: true })

			// Create/overwrite log file with initial entry
			const startMessage = `=== A4D MCP NPM Wrapper ===\n
Package: ${this.packageNameVersion}
Node Bin: ${this.config.nodeBin}
NPX Bin: ${this.config.npxBin}
NPM Bin: ${this.config.npmBin}
Node Version: ${this.config.nodeVersion}
System Node: ${this.config.systemNode}
Cache Dir: ${this.cacheDir}
NPM Logs Dir: ${this.npmLogsDir}
Server Args: ${JSON.stringify(this.config.args)}\n\n`
			await fs.writeFile(this.logFile, startMessage)
		} catch (error) {
			console.error(`[A4D][MCP] Failed to initialize log file: ${error.message}`)
		}
	}

	/**
	 * Initialize the wrapper configuration and load Salesforce Node.js paths
	 *
	 * Sets up environment variables, loads SF Node paths, and initializes logging.
	 */
	async initialize() {
		try {
			// Load Salesforce Node.js paths (SfNodePathResult)
			const sfPaths = await this.loadSfNodePaths()

			// Update config with loaded paths
			this.config.nodeBin = sfPaths.nodeBin
			this.config.npxBin = sfPaths.npxBin
			this.config.npmBin = sfPaths.npmBin
			this.config.nodeVersion = sfPaths.nodeVersion
			this.config.systemNode = sfPaths.systemNode

			// Set up environment with node path and logs directory
			if (!this.config.systemNode) {
				// Set PATH for e.g. postinstall scripts of dependencies to find node/npm/npx
				const nodePathDir = path.dirname(this.config.nodeBin)
				NPM_ENV_VARS.PATH = `${nodePathDir}${path.delimiter}${process.env.PATH}`
			}	
			NPM_ENV_VARS.npm_config_logs_dir = this.npmLogsDir // Set logs directory for npm/npx
			NPM_ENV_VARS.npm_config_cache = this.cacheDir // Set cache directory for npm

			// Initialize log file
			await this.initializeLogFile(this.packageId)
			await this.log(`Wrapper initialized for package: ${this.packageNameVersion} using Node.js ${this.config.nodeVersion} (system node: ${this.config.systemNode})`, "DEBUG")
		} catch (error) {
			await this.logAndThrow(`Failed to initialize wrapper: ${error.message}`)
		}
	}

	/**
	 * Load SF Node paths from sfNodePath.json
	 * The JSON file contains SfNodePathResult with fields: nodeBin, npxBin, npmBin, nodeVersion, systemNode
	 */
	async loadSfNodePaths() {
		const sfNodePathFile = path.join(__dirname, "sfNodePath.json")

		const data = await fs.readFile(sfNodePathFile, "utf-8")
		const paths = JSON.parse(data)

		// Validate required paths exist
		if (!paths.nodeBin || !paths.npxBin || !paths.npmBin) {
			await this.logAndThrow("Missing required node binaries in sfNodePath.json")
		}

		return paths
	}

	/**
	 * Get command and args for executing npm or npx
	 * 
	 * Handles the difference between SF CLI node (file paths) and system node (executables):
	 * - SF CLI: Execute as `node /path/to/npm-cli.js [args]` or `node /path/to/npx-cli.js [args]`
	 * - System: Execute directly as `npm [args]` or `npx [args]`
	 * 
	 * @param {'npm'|'npx'} nodeCmd - Whether to execute npm or npx
	 * @param {string[]} nodeCmdArgs - Arguments to pass to npm/npx
	 * @returns {{command: string, args: string[]}} Command and args ready for spawn
	 */
	async getNodeCommandArgs(nodeCmd, nodeCmdArgs) {
		let command = ""
		let args = []
		const resolvedNodeCmd = nodeCmd === NODE_CMD.NPM ? this.config.npmBin : this.config.npxBin
		if (this.config.systemNode) {
			// System node: execute npm/npx directly
			command = resolvedNodeCmd
			args = nodeCmdArgs
		} else {
			// SF CLI node: execute using node binary with npm/npx file path as first arg
			command = this.config.nodeBin
			args = [resolvedNodeCmd, ...nodeCmdArgs]
		}
		await this.log(`Running command: "${command} ${args.join(" ")}"`, "DEBUG")
		return { command, args }
	}
	/**
	 * Main entry point to install, verify and start the MCP server.
	 *
	 * Orchestrates the complete process: initialize, install/verify server,
	 * start the server. All errors are logged to stderr to avoid corrupting the MCP protocol communication.
	 */
	async run() {
		try {
			await this.initialize()
			await this.resolvePackage()
			await this.ensureInstalled()
			await this.startServer()
		} catch (error) {
			await this.logAndThrow(`Fatal error: ${error.message}. Details: ${this.logFile}`)
		}
	}

	/**
	 * Check if the package exists in npm registry
	 *
	 * @throws {Error} If package does not exist in npm
	 */
	async resolvePackage() {
		await this.log(`Checking if package ${this.packageNameVersion} exists in npm`)
		const { command, args } = await this.getNodeCommandArgs(NODE_CMD.NPM, ["view", this.packageNameVersion, "version"])

		try {
			const resolvedVersion = await spawnProcess(command, args, {
				// cwd: this.cacheDir,
				captureOutput: true,
			})

			this.packageVersion = resolvedVersion
			this.packageNameVersion = `${this.packageName}@${this.packageVersion}`
			await this.log(`Package ${this.packageName} resolved to version ${this.packageVersion}`, "DEBUG")
		} catch (error) {
			await this.logAndThrow(`Package ${this.packageNameVersion} does not exist in npm: ${error.message}`)
		}
	}

	/**
	 * Install and verify the MCP server package
	 *
	 * Optimized approach: Within each retry attempt, first tries to verify if the
	 * package is already installed and working. Only installs if verification fails.
	 * This avoids unnecessary npm installs on every server restart while still
	 * providing robust retry logic.
	 *
	 * Implements retry logic with exponential backoff (up to 3 attempts) to handle
	 * transient network issues, DNS resolution problems, and npm registry timeouts.
	 * Each retry cleans up the cache directory to ensure a fresh installation attempt.
	 *
	 * @throws {Error} If all retry attempts fail
	 */
	async ensureInstalled() {
		await this.log(`Starting installation process with max retries: ${this.maxRetries}`)

		for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
			try {
				await this.log(`Attempt ${attempt}/${this.maxRetries}: Installing and verifying package`)

				// TODO: Optimize to verify-first approach to avoid unnecessary reinstalls
				// If verification fails, try to install the package
				await this.installServer()
				await this.verifyServer()

				await this.log(`Installation and verification successful on attempt ${attempt}`)
				return // Success, exit the retry loop
			} catch (installError) {
				await this.log(`Attempt ${attempt} failed: ${installError.message}`, "ERROR")

				if (attempt < this.maxRetries) {
					await this.log(`Cleaning up cache and retrying ..`)
					await this.cleanupCache()
					await this.delay(1000) // Wait 1 second before retrying
				} else {
					await this.logAndThrow(`All retry attempts exhausted: ${installError.message}`)
				}
			}
		}
	}

	/**
	 * Install the MCP server package using npm
	 *
	 * Creates a package.json with the target package pre-defined in dependencies,
	 * then runs `npm install` to install from the dependency specification.
	 * This approach is more deterministic and matches standard project workflows.
	 *
	 * Uses isolated cache directory to avoid conflicts with other npm operations.
	 * Uses exact version in package.json for deterministic, repeatable installations.
	 *
	 * @throws {Error} If npm install fails
	 */
	async installServer() {
		await this.log("Starting package installation")

		// Ensure cache directory exists
		await fs.mkdir(this.cacheDir, { recursive: true })
		await this.log(`Cache directory created: ${this.cacheDir}`)

		// Create package.json with the target package pre-defined in dependencies
		// This is more deterministic and allows for faster npm installs
		const packageJson = {
			name: "a4d-mcp-wrapper",
			version: "1.0.0",
			description: "A4D MCP server wrapper cache",
			private: true,
			dependencies: {
				[this.packageName]: this.packageVersion,
			},
		}
		const packageJsonPath = path.join(this.cacheDir, "package.json")
		await fs.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2))
		await this.log(`Package.json created at: ${packageJsonPath}`, "DEBUG")

		// Use npm install without specifying package (reads from package.json)
		// Most configuration handled via NPM_ENV_VARS environment variables
		const { command, args } = await this.getNodeCommandArgs(NODE_CMD.NPM, ["install"])

		const installStart = Date.now()
		await spawnProcess(command, args, {
			cwd: this.cacheDir,
		})

		const installDuration = Date.now() - installStart
		await this.log(`Package installation completed in ${this.formatDuration(installDuration)}`)

		// Get and log the exact installed version
		try {
			const installedVersion = await this.getInstalledVersion()
			await this.log(`Installed version of ${this.packageName}: ${installedVersion}`)
		} catch (error) {
			await this.log(`Warning: Could not retrieve installed version: ${error.message}`, "DEBUG")
		}
	}

	/**
	 * Get the exact version of the installed package
	 *
	 * Uses npm list to get the precise version that was installed on disk,
	 * which may differ from the version specified in package.json due to
	 * semver resolution.
	 *
	 * @returns {Promise<string>} The exact installed version string
	 * @throws {Error} If npm list fails or package is not found
	 */
	async getInstalledVersion() {
		const { command, args } = await this.getNodeCommandArgs(NODE_CMD.NPM, ["list", this.packageName, "--json", "--depth=0"])
		const output = await spawnProcess(command, args, {
			cwd: this.cacheDir,
			captureOutput: true,
		})

		let npmListResult = {}
		try {
			npmListResult = JSON.parse(output)
		} catch (parseError) {
			await this.logAndThrow(`Could not parse version from npm list output: ${parseError.message}`)
		}
		// npm list output structure: { dependencies: { "package-name": { version: "1.2.3" } } }
		const packageInfo = npmListResult?.dependencies?.[this.packageName]
		const packageVersion = packageInfo?.version
		if (!packageInfo || !packageVersion) {
			const errorMessage = `[McpServerNpmWrapper.getInstalledVersion] Package ${this.packageName} not found in npm list output`
			await this.logAndThrow(errorMessage)
		}

		return packageVersion
	}

	/**
	 * Verify that the installed server works correctly
	 *
	 * Runs a simple --version command to ensure the package was installed
	 * correctly and can be executed. This catches installation issues before
	 * attempting to start the actual MCP server.
	 *
	 * Uses exact version specification for reliable verification.
	 *
	 * @throws {Error} If server verification fails
	 */
	async verifyServer(verifyCommand = "--version") {
		await this.log("Starting package verification")
		const { command, args } = await this.getNodeCommandArgs(NODE_CMD.NPX, [...NPX_ARGS, this.packageNameVersion, verifyCommand])
		const verifyStart = Date.now()
		try {
			await spawnProcess(command, args, {
				cwd: this.cacheDir, // Run from cache directory
			})

			const verifyDuration = Date.now() - verifyStart
			await this.log(`Package verification successful in ${this.formatDuration(verifyDuration)}`)
			return true
		} catch (error) {
			const verifyDuration = Date.now() - verifyStart
			await this.logAndThrow(`Package verification failed after ${this.formatDuration(verifyDuration)}: ${error.message}`)
		}
	}

	/**
	 * Start the MCP server with transparent stdio forwarding
	 *
	 * CRITICAL: Uses stdio: 'inherit' to make this wrapper process transparent
	 * to the MCP protocol. The wrapper's stdin/stdout are directly connected
	 * to the MCP server's stdin/stdout, allowing clean protocol communication.
	 * This method blocks until the server process exits, which is expected
	 * behavior for MCP servers that run indefinitely.
	 *
	 * @throws {Error} If server fails to start or exits unexpectedly
	 */
	async startServer() {
		await this.log("Starting MCP server")

		// CRITICAL: Use stdio: 'inherit' to pass through stdin/stdout cleanly
		try {
			await this.log(`Starting server with args: ${JSON.stringify(this.config.args)}`, "DEBUG")
			const { command, args } = await this.getNodeCommandArgs(NODE_CMD.NPX, [...NPX_ARGS, this.packageNameVersion, ...this.config.args])
			await spawnProcess(command, args, {
				cwd: this.cacheDir, // Run from cache directory
				stdio: "inherit", // IMPORTANT - passes stdin/stdout directly to the MCP server
			})

			await this.log("MCP server process stopped")
		} catch (error) {
			await this.logAndThrow(`Error while starting MCP server ${this.packageNameVersion}: ${error.message}`)
		}
	}

	/**
	 * Clean up the package-specific cache directory
	 *
	 * Removes the entire package cache directory to ensure a clean state for the next
	 * installation attempt. The log file is preserved as it's stored in the base
	 * cache directory, not the package-specific cache directory.
	 *
	 * Failures are logged but don't stop execution as cleanup is not critical.
	 */
	async cleanupCache() {
		await this.log(`Cleaning up package cache directory: ${this.cacheDir}`)

		try {
			await fs.rm(this.cacheDir, { recursive: true, force: true })
			await this.log("Package cache cleanup completed successfully")
		} catch (error) {
			await this.log(`Failed to cleanup package cache: ${error.message}`, "ERROR")
		}
	}

	/**
	 * Format milliseconds into a human-readable duration string
	 * @param {number} ms - Duration in milliseconds
	 * @returns {string} Formatted duration (e.g., "2m 30s 500ms", "45s 200ms", "1.2s")
	 */
	formatDuration(ms) {
		if (ms < 1000) {
			return `${ms}ms`
		}

		const minutes = Math.floor(ms / 60000)
		const seconds = Math.floor((ms % 60000) / 1000)
		const remainingMs = ms % 1000

		const result = []
		if (minutes > 0) {
			result.push(`${minutes}m`)
		}
		if (seconds > 0) {
			result.push(`${seconds}s`)
		}
		if (remainingMs > 0 && result.length < 2) {
			result.push(`${remainingMs}ms`)
		}

		return result.join(" ") || "0ms"
	}

	/**
	 * Utility method for delays
	 * @param {number} ms - Milliseconds to delay
	 */
	delay(ms) {
		return new Promise((resolve) => setTimeout(resolve, ms))
	}
}

/**
 * Parse command line arguments containing server (package[@version]) and its arguments
 *
 * Usage: node a4d-mcp-wrapper.js <package[@version]> [args...]
 * Examples:
 *   node a4d-mcp-wrapper.js @salesforce/mcp@1.0.0 --orgs ALLOW_ALL_ORGS --toolsets all
 *   node a4d-mcp-wrapper.js @salesforce/mcp --orgs ALLOW_ALL_ORGS --toolsets all  # defaults to latest
 *   node a4d-mcp-wrapper.js some-package  # defaults to latest
 */
function parseCommandLineArgs() {
	const { positionals } = parseArgs({
		allowPositionals: true,
		strict: false, // Allow unknown options to be passed to the MCP server
	})

	const helpMessage = `Usage: node a4d-mcp-wrapper.js <package[@version]> [args...]
Examples:
  node a4d-mcp-wrapper.js @salesforce/mcp@1.0.0 --orgs ALLOW_ALL_ORGS --toolsets all  `
	// parseArgs filters out the script name (e.g. a4d-mcp-wrapper.js), so positionals[0] is the package name
	if (positionals.length < 1) {
		throw new Error(`Package name required as first argument\n${helpMessage}`)
	}

	const packageRef = positionals[0]
	const serverArgs = process.argv.slice(3) // Get remaining args after script name and package@version

	// Parse package[@version] format, default to "latest" if no version specified
	const lastAtIndex = packageRef.lastIndexOf("@")
	let packageName, version

	if (lastAtIndex === -1) {
		// No @ found, treat entire spec as package name and default to latest
		packageName = packageRef
		version = "latest"
	} else if (lastAtIndex === 0) {
		// @ at start, this is a scoped package without version (e.g., "@salesforce/mcp")
		packageName = packageRef
		version = "latest"
	} else {
		// Contains @, check if it's package@version format
		const parsedPackageName = packageRef.substring(0, lastAtIndex)
		const parsedVersion = packageRef.substring(lastAtIndex + 1)

		if (!parsedVersion) {
			// package@ with empty version, default to latest
			packageName = parsedPackageName
			version = "latest"
		} else {
			// Normal package@version format
			packageName = parsedPackageName
			version = parsedVersion
		}
	}

	if (!packageName || !version) {
		throw new Error(`Invalid package format: ${packageRef}. Expected format: package[@version]\n${helpMessage}`)
	}

	return {
		package: packageName,
		version: version,
		args: serverArgs,
	}
}

// Auto-execute when script is run
async function main() {
	try {
		const { package: packageName, version, args } = parseCommandLineArgs()

		const wrapper = new McpServerNpmWrapper({
			package: packageName,
			version,
			args,
		})

		await wrapper.run()
	} catch (error) {
		// Centralized error handling - all thrown errors end up here
		// Log error with stack trace for debugging
		console.error(`[A4D][MCP] FATAL ERROR: MCP wrapper failed: ${error.message}`)
		if (error.stack) {
			console.error(`Stack trace: ${error.stack}`)
		}
		// Single exit point for the entire application
		process.exit(1)
	}
}

main()
